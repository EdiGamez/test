import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.job.builder.JobBuilderFactory;
import org.springframework.batch.core.listener.JobExecutionListener;
import org.springframework.batch.core.listener.StepExecutionListener;
import org.springframework.batch.core.step.builder.StepBuilderFactory;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import static org.junit.Assert.*;

@RunWith(JUnit4.class) // Cambiado a JUnit4 para ser explícito
public class JobConfigExtractTaylorReportDbTest {

    // No hay mocks de Mockito aquí

    private JobBuilderFactory jobBuilderFactory;
    private StepBuilderFactory stepBuilderFactory;
    private Tasklet taylorReportLoadDatabase;
    private JobConfigExtractTaylorReportDb jobConfig;

    @Test
    public void testJobExtracFullRevalReportDb() {
        // Arrange
        String jobName = "jobExtracTaylorReportDb";
        // En lugar de mocks, usamos implementaciones reales o stubs muy simples
        jobBuilderFactory = new TestJobBuilderFactory();
        stepBuilderFactory = new TestStepBuilderFactory();
        taylorReportLoadDatabase = new TestTasklet(); // Un Tasklet vacío para este test
        jobConfig = new JobConfigExtractTaylorReportDb();
        ReflectionTestUtils.setField(jobConfig, "dataDatePart", "20230101"); // Valores para el logger
        ReflectionTestUtils.setField(jobConfig, "unit", "MXN");

        // Act
        Job actualJob = jobConfig.jobExtracFullRevalReportDb(jobBuilderFactory, taylorReportLoadDatabase, stepBuilderFactory);

        // Assert
        assertNotNull(actualJob);
        assertEquals(jobName, actualJob.getName());
        // Aquí podrías agregar más aserciones para verificar la configuración del Job
        // Por ejemplo, podrías usar reflection para inspeccionar los pasos del Job
    }

    @Test
    public void testStepFrLoadDb() {
        // Arrange
        String stepName = "stepFrLoadDb";
        stepBuilderFactory = new TestStepBuilderFactory();
        taylorReportLoadDatabase = new TestTasklet();
        jobConfig = new JobConfigExtractTaylorReportDb(); //Necesario para que no sea null y lance NullPointerException
        ReflectionTestUtils.setField(jobConfig, "dataDatePart", "20230101"); // Valores para el logger
        ReflectionTestUtils.setField(jobConfig, "unit", "MXN");

        // Act
        Step actualStep = jobConfig.stepFrLoadDb(taylorReportLoadDatabase, stepBuilderFactory);

        // Assert
        assertNotNull(actualStep);
        assertEquals(stepName, actualStep.getName());
        // Aquí podrías agregar más aserciones para verificar la configuración del Step
    }

    @Test
    public void testJobListenerBeforeJob() {
        // Arrange
        JobConfigExtractTaylorReportDb.JobListener jobListener = jobConfig.new JobListener();
        JobExecution jobExecution = new JobExecution(1L);
        JobInstance jobInstance = new JobInstance(1L, "jobExtracTaylorReportDb");
        jobExecution.setJobInstance(jobInstance);
        ReflectionTestUtils.setField(jobConfig, "dataDatePart", "20230101");
        ReflectionTestUtils.setField(jobConfig, "unit", "MXN");
        Logger logger = new TestLogger(); // Usamos nuestro logger de prueba
        ReflectionTestUtils.setField(jobListener, "log", logger);

        // Act
        jobListener.beforeJob(jobExecution);

        // Assert
        TestLogger testLogger = (TestLogger) logger;
        assertEquals("INI BATCH: jobExtracTaylorReportDb - DATA_DATE: 20230101 - UNIT: MXN", testLogger.getLastMessage());
    }

    @Test
    public void testJobListenerAfterJob() {
        // Arrange
        JobConfigExtractTaylorReportDb.JobListener jobListener = jobConfig.new JobListener();
        JobExecution jobExecution = new JobExecution(1L);
        JobInstance jobInstance = new JobInstance(1L, "jobExtracTaylorReportDb");
        jobExecution.setJobInstance(jobInstance);
        ReflectionTestUtils.setField(jobConfig, "dataDatePart", "20230101");
        ReflectionTestUtils.setField(jobConfig, "unit", "MXN");
        ReflectionTestUtils.setField(jobListener, "init", Instant.now().minusSeconds(5));
        Logger logger = new TestLogger();
        ReflectionTestUtils.setField(jobListener, "log", logger);
        ReflectionTestUtils.setField(jobConfig, "durationMessages", new ArrayList<>());

        // Act
        jobListener.afterJob(jobExecution);

        // Assert
        TestLogger testLogger = (TestLogger) logger;
        List<String> logMessages = testLogger.getMessages();
        assertEquals("FIN BATCH: jobExtracTaylorReportDb - DATA_DATE: 20230101 - UNIT: MXN", logMessages.get(0));
        assertTrue(logMessages.get(1).contains("DURATION entire process:"));
        assertTrue(logMessages.get(2).contains("PROCESS Finished"));
        List<String> durationMessages = (List<String>) ReflectionTestUtils.getField(jobConfig, "durationMessages");
        assertEquals(1, durationMessages.size());
        assertTrue(durationMessages.get(0).contains("DURATION JOB: jobExtracTaylorReportDb -"));
    }

    @Test
    public void testStepGenerarListenerBeforeStep() {
        // Arrange
        JobConfigExtractTaylorReportDb.StepGenerarListener stepListener = jobConfig.new StepGenerarListener();
        StepExecution stepExecution = new StepExecution("stepFrLoadDb", new JobExecution(1L));
        ReflectionTestUtils.setField(jobConfig, "dataDatePart", "20230101");
        ReflectionTestUtils.setField(jobConfig, "unit", "MXN");
        Logger logger = new TestLogger();
        ReflectionTestUtils.setField(stepListener, "log", logger);

        // Act
        stepListener.beforeStep(stepExecution);

        // Assert
        TestLogger testLogger = (TestLogger) logger;
        assertEquals("INI STEP: stepFrLoadDb - DATA_DATE: 20230101 - UNIT: MXN", testLogger.getLastMessage());
    }

    @Test
    public void testStepGenerarListenerAfterStep() {
        // Arrange
        JobConfigExtractTaylorReportDb.StepGenerarListener stepListener = jobConfig.new StepGenerarListener();
        StepExecution stepExecution = new StepExecution("stepFrLoadDb", new JobExecution(1L));
        ReflectionTestUtils.setField(jobConfig, "dataDatePart", "20230101");
        ReflectionTestUtils.setField(jobConfig, "unit", "MXN");
        ReflectionTestUtils.setField(stepListener, "init", Instant.now().minusSeconds(3));
        Logger logger = new TestLogger();
        ReflectionTestUtils.setField(stepListener, "log", logger);
        ReflectionTestUtils.setField(jobConfig, "durationMessages", new ArrayList<>());

        // Act
        ExitStatus exitStatus = stepListener.afterStep(stepExecution);

        // Assert
        TestLogger testLogger = (TestLogger) logger;
        assertEquals("FIN STEP: stepFrLoadDb - DATA_DATE: 20230101 - UNIT: MXN", testLogger.getLastMessage());
        assertNull(exitStatus);
        List<String> durationMessages = (List<String>) ReflectionTestUtils.getField(jobConfig, "durationMessages");
        assertEquals(1, durationMessages.size());
        assertTrue(durationMessages.get(0).contains("DURATION STEP: stepFrLoadDb -"));
    }

    @Configuration
    @EnableBatchProcessing
    static class TestConfig {
        @Bean
        public Tasklet mockTasklet() {
            return new Tasklet() {
                @Override
                public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
                    return RepeatStatus.FINISHED;
                }
            };
        }
    }

    @Test
    public void testContextLoads() {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(JobConfigExtractTaylorReportDb.class, TestConfig.class);
        assertNotNull(context.getBean("jobExtracFullRevalReportDb"));
        assertNotNull(context.getBean("stepFrLoadDb"));
        context.close();
    }

    // Implementaciones de prueba (Stubs)
    private static class TestJobBuilderFactory extends JobBuilderFactory {
        private int jobCount = 0;

        public TestJobBuilderFactory() {
            super(null); // No necesitamos un JobRepository real para estas pruebas
        }

        @Override
        public JobBuilder get(String name) {
            jobCount++;
            return new JobBuilder(name, null) { // También un JobBuilder de prueba
                @Override
                public Job build() {
                    Job job = new Job() {
                        @Override
                        public String getName() {
                            return name;
                        }
                    };
                    return job;
                }
            };
        }
    }

    private static class TestStepBuilderFactory extends StepBuilderFactory {
        private int stepCount = 0;

        public TestStepBuilderFactory() {
            super(null, null); // No necesitamos un JobRepository ni TransactionManager
        }

        @Override
        public StepBuilder get(String name) {
            stepCount++;
            return new StepBuilder(name, null) {
                @Override
                public Step build() {
                    return new Step() {
                        @Override
                        public String getName() {
                            return name;
                        }

                        @Override
                        public void execute(JobExecution jobExecution) throws JobInterruptedException, UnexpectedJobExecutionException, JobRestartException, NonTransientResourceException {

                        }

                        @Override
                        public boolean isSkippable() {
                            return false;
                        }

                        @Override
                        public boolean isAllowStartIfComplete() {
                            return false;
                        }
                    };
                }
            };
        }
    }

    private static class TestTasklet implements Tasklet {
        @Override
        public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
            return RepeatStatus.FINISHED;
        }
    }

    private static class TestLogger extends Logger {
        private String lastMessage;
        private List<String> messages = new ArrayList<>();

        protected TestLogger() {
            super("TestLogger", null);
        }

        @Override
        public void log(Level level, String msg) {
            lastMessage = msg;
            messages.add(msg);
            // No imprimimos a la consola para no contaminar la salida de la prueba
        }

        public String getLastMessage() {
            return lastMessage;
        }

        public List<String> getMessages() {
            return messages;
        }
    }
}

