package com.sgt.rfr.rfrmomservice.service;

import java.io.IOException;
import java.math.BigDecimal;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.Instant;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import com.sgt.rfr.rfrmomservice.util.cache.CacheBatchInMemoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.isb.rfrutils.domain.momservice.MomResult;
import com.isb.rfrutils.domain.momservice.NewMsgMomUpdInfoRequest;
import com.isb.rfrutils.domain.momservice.UpdMomInfResponse;
import com.isb.rfrutils.domain.request.MsgGenericRequestSCM;
import com.isb.rfrutils.domain.request.SigomModInfoCleanRequest;
import com.isb.rfrutils.domain.request.StaticsListRequest;
import com.isb.rfrutils.exception.RfrException;
import com.isb.rfrutils.services.LoggerService;
import com.isb.rfrutils.services.MonitorMOM;
import com.isb.rfrutils.services.RestKafkaWriterConsumerService;
import com.isb.rfrutils.services.RestSigomConsumerService;
import com.isb.rfrutils.util.RfrCommonCTES;
import com.sgt.rfr.rfrmomservice.database.repository.MsgCacheProcessRepo;
import com.sgt.rfr.rfrmomservice.util.scheduler.Scheduler;

//TODO: Revisar funcionalidad
//TODO: Reponer comentarios de nuevos metodos
@Service
@Transactional
public class UpdInfMomService {

    @Autowired
    private LoggerService log;

    @Autowired
    private RestSigomConsumerService rcs;
    
    @Autowired
    private RestKafkaWriterConsumerService kafkaWriterService;
    
    @Autowired
    private MsgCacheProcessRepo cacheProcessRepo;
    
    @Autowired
    private MonitorMOM monitor;
    
    @Autowired
	private CacheBatchInMemoryService cacheBatchInMemoryService;
    
    private static HashMap<String, BigDecimal> assetClassMap;
    private static HashMap<String, BigDecimal> factorTypeMap;
    
    private Instant inicio = null;
    private Long contador = 0l;

	/**
	 * Generate kafka modelability message response
	 * @param request
	 * @return
	 * @throws RfrException
	 */
	public MsgGenericRequestSCM mpeOpeInvoke(NewMsgMomUpdInfoRequest request) throws RfrException {
		// Se desencadena el proceso de envio de inventario al MPE
		SimpleDateFormat dateFormatYYYYMMDD = new SimpleDateFormat(RfrCommonCTES.DATEFORMAT_YYYYMMDD);
		SimpleDateFormat dateFormatTimestamp = new SimpleDateFormat("yyyyMMddHHmmss");
		String timestamp  = dateFormatTimestamp.format(new Date());
		String idFunctionality = request.getMomResult().getAssetClass() + "_" + request.getMomResult().getFactorType() + "_" + RfrCommonCTES.Operations.SE_MPE.toUpperCase() + "_" + timestamp;
		MsgGenericRequestSCM mpeRequest = new MsgGenericRequestSCM();
		mpeRequest.setIdFunctionality(idFunctionality);
		mpeRequest.setUnit("ES");
		mpeRequest.setSourceSystem(RfrCommonCTES.SOURCE_SYS_RFR);
		mpeRequest.setType(RfrCommonCTES.TYPE_SYS_RFR);
		mpeRequest.setAssetClass(request.getMomResult().getAssetClass());
		mpeRequest.setFactorType(request.getMomResult().getFactorType());
		mpeRequest.setOperation(RfrCommonCTES.Operations.SE_MPE);
		mpeRequest.setCalcDate(dateFormatYYYYMMDD.format(new Date()));
		mpeRequest.setResponseQueue("");
		String[] idSplited = request.getHeaderCtrl().getIdFunctionality().split("_", -1);
		String idFunctionMom = idSplited[0] + "_" + idSplited[1];
		log.logInfo("Borramos del mapa el idFunctionality de MOM: "+idFunctionMom);
		cacheBatchInMemoryService.clearState(idFunctionMom);
		return mpeRequest;
	}

	/**
	 * Obtención de la PK del Underlying
	 *
	 * @param request
	 * @return
	 * @throws RfrException
	 */
public Boolean updMomInf(NewMsgMomUpdInfoRequest request) throws RfrException {
    initializeStaticMaps(rcs);
    validateStaticMaps();

    Boolean isAllBatchProcessed = false;
    ObjectMapper objectMapper = new ObjectMapper();

    try {
        Scheduler.lockStatics();
        logRequestStart(request);

        String idFunction = processRequestAndCache(request);
        int numTotMsg = updateBatchCount(idFunction);

        if (numTotMsg == 1) {
            startTimer();
        }

        if (numTotMsg == request.getHeaderCtrl().getTotal()) {
            processAllMessages(request, idFunction, objectMapper);
            isAllBatchProcessed = true;
        }

        log.logDebug(RfrCommonCTES.Messages.MESSAGE_END + "updMomInf");
    } catch (Exception e) {
        log.logException(e);
    } finally {
        Scheduler.unlockStatics();
    }

    return isAllBatchProcessed;
}

private static void initializeStaticMaps(RestSigomConsumerService rcs) {
    if (assetClassMap == null) {
        assetClassMap = rcs.getStaticList(new StaticsListRequest("AssetClass"));
    }
    if (factorTypeMap == null) {
        factorTypeMap = rcs.getStaticList(new StaticsListRequest("FactorType"));
    }
}

private void validateStaticMaps() {
    if (assetClassMap.isEmpty() || factorTypeMap.isEmpty()) {
        log.logWarning(RfrCommonCTES.Messages.WARN_STATIC_MAPS_EMPTY);
    }
}

private void logRequestStart(NewMsgMomUpdInfoRequest request) {
    log.logInfo(RfrCommonCTES.Messages.MESSAGE_START + " updMomInf -> NewMsgMomUpdInfoRequest: " + request.toString());
}

private String processRequestAndCache(NewMsgMomUpdInfoRequest request) throws RfrException, SQLException {
    SimpleDateFormat dateFormat = new SimpleDateFormat(RfrCommonCTES.DATEFORMAT);
    String msgInsert = new GsonBuilder().serializeNulls().create().toJson(request);
    log.logDebug("Objeto parseado a String con formato JSON ---> " + msgInsert);

    String[] idSplited = request.getHeaderCtrl().getIdFunctionality().split("_", -1);
    String idFunction = idSplited[0] + "_" + idSplited[1];

    cacheProcessRepo.callInsertMessageIntoCache(
        idFunction,
        request.getMomResult().getAssetClass(),
        request.getMomResult().getFactorType(),
        request.getOperation(),
        msgInsert,
        request.getHeaderCtrl().getCurrent(),
        request.getHeaderCtrl().getTotal(),
        dateFormat.format(new Date())
    );

    return idFunction;
}

private int updateBatchCount(String idFunction) {
    cacheBatchInMemoryService.getBatches().merge(idFunction, 1, Integer::sum);
    return cacheBatchInMemoryService.getBatches().get(idFunction);
}

private void startTimer() {
    inicio = Instant.now();
    log.logInfo("--------------------Se inicia el temporizador----------------");
}

private void processAllMessages(NewMsgMomUpdInfoRequest request, String idFunction, ObjectMapper objectMapper) throws Exception {
    Instant fin = Instant.now();
    long duracion = Duration.between(inicio, fin).getSeconds();
    log.logInfo("---------Duración conteo de todos los mensajes------------UpdInfMomService------------- " + duracion);
    contador = 0L;

    log.logInfo("Se empiezan a procesar todos los mensajes de Mod");
    List<String> messages = cacheProcessRepo.readMsgFromCache(
        idFunction,
        request.getMomResult().getAssetClass(),
        request.getMomResult().getFactorType(),
        request.getOperation()
    );

    cleanModInfo(request);

    for (String message : messages) {
        processMessage(message, idFunction, objectMapper);
    }

    log.logInfo("Se acaba de procesar todos los mensajes de Mod");
}

private void cleanModInfo(NewMsgMomUpdInfoRequest request) throws RfrException {
    SigomModInfoCleanRequest cleanModInfoReq = new SigomModInfoCleanRequest();
    cleanModInfoReq.setAssetClass(assetClassMap.get(request.getMomResult().getAssetClass()));
    cleanModInfoReq.setFactorType(factorTypeMap.get(request.getMomResult().getFactorType()));
    cleanModInfoReq.setNewFlag("1");
    rcs.cleanModInfo(cleanModInfoReq);
}

private void processMessage(String message, String idFunction, ObjectMapper objectMapper) throws Exception {
    NewMsgMomUpdInfoRequest msgRequest = objectMapper.readValue(message, NewMsgMomUpdInfoRequest.class);
    MomResult momR = createMomResult(msgRequest, idFunction);

    log.logInfo("Request a sigom ---> " + momR.toString());
    rcs.updMomInf(momR);
    monitor.notifyModelabilityRequestSended(momR);
}

private MomResult createMomResult(NewMsgMomUpdInfoRequest msgRequest, String idFunction) {
    MomResult momR = new MomResult();
    momR.setFlag(null);
    momR.setIdFuncioality(idFunction);
    momR.setUnderlying(msgRequest.getMomResult().getUnderlying());
    momR.setAssetClass(msgRequest.getMomResult().getAssetClass());
    momR.setFactorType(msgRequest.getMomResult().getFactorType());
    momR.setAxisX(msgRequest.getMomResult().getAxisX());
    momR.setAxisY(msgRequest.getMomResult().getAxisY());
    momR.setAxisZ(msgRequest.getMomResult().getAxisZ());
    momR.setLostDate(msgRequest.getMomResult().getLostDate());
    momR.setFlagDate(msgRequest.getMomResult().getFlagDate());
    momR.setFlag(determineFlag(msgRequest));
    momR.setNewFlag("1");
    return momR;
}

private String determineFlag(NewMsgMomUpdInfoRequest msgRequest) {
    if (msgRequest.getMomResult() != null && RfrCommonCTES.MomFlag.FLAG_Y.equalsIgnoreCase(msgRequest.getMomResult().getFlag())) {
        return "1";
    } else if (RfrCommonCTES.MomFlag.FLAG_N.equalsIgnoreCase(msgRequest.getMomResult().getFlag())) {
        return "0";
    }
    return null;
}
    /**
	 * UpdMomInfResponse old version
     * @param request
     * @return
     * @throws RfrException
     */
    public Boolean updMomInfRest(NewMsgMomUpdInfoRequest request) throws RfrException {
		Boolean updMomInfResponse= updMomInf(request);
		log.logInfo(updMomInfResponse.toString());
		MsgGenericRequestSCM mpeRequest = mpeOpeInvoke(request);
		log.logInfo(mpeRequest.toString());
		return updMomInfResponse;
    }

	public static void resetMaps(){
    	assetClassMap = null;
    	factorTypeMap = null;
    }
}
